fn main() {
    _smallest_multiple();
    //_largest_palindrome_product();            //problem4
    //_largest_prime_factor(600_851_475_143.0); //problem3
    //_even_fibonacci_numbers(4_000_000);       //problem2
    //_multiples_of_3_or_5(1000);               //problem1
}

fn _smallest_multiple() {
    //2520 is the smalles number that can be divided by each of the numbers from 1 to 10 without any remainder
    //what is the smallest positive number that is evenly divisible by all the numbers from 1 to 20

    //so, it's at least an even number
    //1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ,16 ,17, 18, 19, 20
    //1:    1 x 1           //2:  2 x 1
    //2:    1 x 2           //4:  2 x 2
    //3:    1 x 3           //6:  2 x 3
    //4:    2 x 2           //8:  2 x 2 x 2
    //5:    1 x 5           //10: 2 x 5
    //6:    2 x 3           //12: 2 x 2 x 3
    //7:    1 x 7           //14: 2 x 7
    //8:    2 x 2 x 2       //16: 2 x 2 x 2 x 2
    //9:    3 x 2           //18: 2 x 3 x 3
    //10:   2 x 5           //20: 2 x 2 x 5
    //11:   1 x 11          //22: 2 x 11
    //12:   2 x 2 x 3       //24: 2 x 2 x 2 x 3
    //13:   1 x 13          //26: 2 x 13
    //14:   2 x 7           //28: 2 x 2 x 7
    //15:   5 x 3           //30: 2 x 3 x 5
    //16:   2 x 2 x 2 x 2   //32: 2 x 2 x 2 x 2 x 2
    //17:   1 x 17          //34: 2 x 17
    //18:   3 x 3 x 2       //36: 2 x 2 x 3 x 3
    //19:   19 x 1          //38: 2 x 19
    //20:   5 x 2 x 2       //40: 2 x 2 x 2 x 5


    // let mut i: usize = 0;
    // loop {
    //     i += 20;
    //     for num in 2..20 {
    //         if i % num != 0 {
    //             println!("{i}... nope"); 
    //             break;
    //         }
    //         else if num == 20 {
    //             println!("winner: {i}");
    //             return;
    //         }
    //     }
    // }
    //thoughts...
    //  eventually crashes! no good, need to do this a different way then
}

//bot thoughts -
//  by increasing range by a in second loop don't need to do multiples twice
//      I calculated for 580085, but that wasn't the largest possible, so, by setting the largest and finishing iter
//          the highest result ends up being 906609

fn _largest_palindrome_product() {
    let mut largest: usize = 0;
    for a in (100..1000).rev() {
        for b in (a..1000).rev() {
            let product = (a * b).to_string();
            let reverse: String = product.chars().rev().collect();
            if product == reverse && (a * b) > largest {
                largest = a * b;
            }
        }
    }
    println!("largest: {largest}");
}

//              ==============================//==============================//==============================
//    ==============================//   wonderful functions for previous problems below  //==============================
//              ==============================//==============================//==============================

fn _largest_prime_factor(number: f64) {

    println!("input: {number}\n--------");

    let sqrt = number.sqrt().round() as usize;

    let mut factors: Vec<usize> = vec![];

    for each in (1..sqrt).rev() {
        if number as usize % each == 0 {
            println!("{each} x {} = {}", sqrt / each, sqrt);
            factors.push(each);
        }
    }

    println!("factors: {factors:?}");

    for factor in factors {

        println!("checking factor: {factor}");

        let mut factor_factors: Vec<usize> = vec![];

        for each in (1..factor / 2).rev() {
            if factor % each == 0 {
                println!("...");
                factor_factors.push(each);
            }
        }

        if factor_factors.len() < 2 {
            println!("{factor} was prime!");
            return;
        }
    }
}

// bot answer
//
// pub fn largest_prime_factor(mut n: u64) -> u64 {
//     let mut largest_factor = 1;
    
//     // Handle all factors of 2 first
//     while n % 2 == 0 {
//         largest_factor = 2;
//         n /= 2;
//     }
    
//     // Now we only need to check odd numbers up to sqrt(n)       //<--- hadn't realized this, but yeah, evens could have been skipped for speed
//     let mut i = 3;
//     while i * i <= n {
//         while n % i == 0 {
//             largest_factor = i;
//             n /= i;
//         }
//         i += 2;  // Only check odd numbers
//     }
    
//     // If n is greater than 2, it's prime and is the largest factor
//     if n > 2 {
//         largest_factor = n;
//     }
    
//     largest_factor
// }


fn _even_fibonacci_numbers(number: usize) {

    //the question; each new term in the fibonacci sequence is generated by adding the previous two terms
    //  by starting with 1 and 2, the first 10 terms will be
    //      1, 2, 3, 5, 8, 13, 21, 34, 55, 89
    //by considering the terms in the fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms

    let mut current: [usize; 2] = [1, 2];

    let mut even_sums: usize = 2;

    while current.iter().sum::<usize>() <= number {

        let sum: usize = current.iter().sum();

        if sum % 2 == 0 {

            even_sums += sum;

        }

        current[0] = current[1];
        current[1] = sum;

    }

    println!("sum of even fibs up to {number}: {even_sums}");

}

/*bot thoughts - at first the bot suggest the same thing, but only using two ints instead of a usize array like I did
    upon asking for an alternative approach it showed this interesting implementation for a Fibbonacci struct
        the struct as the Iterator trait implied onto it, and the required next method is written
            the next method does the same function, returning an option of Item (a part of iters)
                the option contains the next numerical value in the fibonacci sequence!
                    it'd be interesting to also write a .back, or .reverse function for this iterator : )
            an addition, the fibo sequence can be started with two arbitrary numbers in this case in the struct
                which I liked; also when written in this way it's possible to take filter results similar to how
                    the problem 1 was done in a functional style

struct Fibonacci {
    curr: u64,
    next: u64,
}

impl Iterator for Fibonacci {
    type Item = u64;
    
    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;
        
        // Calculate the next Fibonacci number
        self.curr = self.next;
        self.next = current + self.next;
        
        Some(current)
    }
}

// Create a new Fibonacci sequence iterator starting with 1, 2
fn fibonacci() -> Fibonacci {
    Fibonacci { curr: 1, next: 2 }
}

pub fn even_fibonacci_sum(limit: u64) -> u64 {          <--- note use of functional programming instead of imperative
    fibonacci()
        .take_while(|&x| x <= limit)  // Only take numbers up to our limit
        .filter(|x| x % 2 == 0)       // Keep only even numbers
        .sum()                        // Sum them up
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_even_fibonacci_sum() {
        assert_eq!(even_fibonacci_sum(89), 44);  // Sum of 2, 8, 34
        assert_eq!(even_fibonacci_sum(4_000_000), 4613732);
    }
}

*/

fn _multiples_of_3_or_5(number: usize) {

    let mut sum: usize = 0; 

    for each in 1..number {
        if each % 3 == 0 || each % 5 == 0 { sum += each; }
    }

    println!("sum: {sum}");
}

fn _claude_mutiple_of_3_or_5(number: i32) {

    let sum: i32 = (1..number)
        .filter(|&x| x % 3 == 0 || x % 5 == 0)
        .sum();
    
    println!("The sum of all multiples of 3 or 5 below {} is: {}", number, sum);
}

fn _claude_wood_hybrid_multiple_of_3_or_5(number: usize) -> usize {

    (1..number).filter(|&x| x % 3 == 0 || x % 5 == 0).sum()
    
}

/*bot thoughts

The "better" solution depends on your needs:

    Imperative So lution (First one):

        Easy to read and understand, especially for beginners
        Very explicit about what's happening at each step
        Uses usize which is more appropriate for this case (we're counting natural numbers)
        Slightly more verbose
        Requires manual management of mutable state (let mut sum)

    Functional Solution (Second one):

        More concise and elegant
        No mutable state to manage
        More "Rust-like" in its use of iterators
        Easier to modify or chain with other operations
        Might be less intuitive for beginners
        Uses i32 which is less ideal than usize for this case

If code readability and maintainability by a team of mixed experience levels is priority, the first solution is better.

If you want more idiomatic Rust code that's easier to modify and chain with other operations, the second solution is better.

pub fn multiples_of_3_or_5(number: usize) -> usize {
    (1..number)
        .filter(|&x| x % 3 == 0 || x % 5 == 0)
        .sum()
}


My recommendation would be a hybrid approach:

This keeps the functional style's elegance but:

Uses usize instead of i32
Returns the value instead of printing it
Separates the logic from the output

This makes it more reusable and type-safe while maintaining readability.
*/

/*
personal opinions:

    elegant code is for when you have time to waste on form over function.

    the functional style is better even though it's probably the same because
    it may not be the same in more complicated maths.

    understanding the functions the bot used:

        Trait std::iter::Iterator

        (1..number) as a direct input for an iterator... this creates a std::iter::Iterator, and the methods that work for them work on it

            cool, why for loop when you can just do this

        .filter() method of iterators

            Creates an iterator which uses a closure to determine if an element should be yielded.
            Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.

            filter is like a .map that returns the element not the result of the predicate in the case of true false
            in this example the predicate is element if 'x % 3 == 0 || x % 5 == 0', and if it's true, x itself is returned instead of true or false
            in place of x

        .sum() method of iterators

            sums up all the elements of an iterator _including_ options and results?
            if the total sum overflows the thread will panic if debug assertions are enabled

            an empty iterator will return the 0 value of the type, so for usize, 0, but an unusual type may have an unusual 0 return value

    there are like 50 other iterators to worry about, like product, cmp, and many more

*/
